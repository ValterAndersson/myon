# ViewModels — Module Architecture

ViewModels manage observable state and business logic for SwiftUI views. They coordinate between Services, Repositories, and Views.

## File Inventory

| File | Primary Views | Responsibilities |
|------|---------------|------------------|
| `CanvasViewModel.swift` | `CanvasScreen`, all card views | Agent streaming, artifact rendering, conversation state, action dispatch |
| `ExercisesViewModel.swift` | Exercise search views | Exercise catalog fetching and search |
| `WorkoutCoachViewModel.swift` | `WorkoutCoachView` | Ephemeral in-memory chat during active workout. Streams agent responses via `DirectStreamingService.streamQuery(workoutId:)` with workout context prefix. Chat is not persisted to Firestore. Mirrors `CanvasViewModel` streaming pattern (message buffer, flush on `.done`). Uses per-workout computed `conversationId` (`"workout-{workoutId}"`) for Vertex AI session isolation. Publishes `activeToolLabel` (from `.toolRunning`/`.toolComplete` SSE events) for tool activity pill display. |

## CanvasViewModel (Primary)

The central ViewModel managing the conversation + artifact experience:

**State:**
- `cards: [CanvasCardModel]` — Artifact cards built from SSE `artifact` events
- `streamEvents: [StreamEvent]` — SSE events for workspace timeline display
- `workspaceEvents: [WorkspaceEvent]` — Persisted conversation history
- `thinkingState: ThinkingProcessState` — Collapsible thought process UI
- `canvasId` (used as conversationId), `currentSessionId`, `currentUserId`

**Key Methods:**
- `start(userId:purpose:)` — Create conversation via `openCanvas()`, attach Firestore listeners
- `startSSEStream()` — Begin agent streaming via `DirectStreamingService`
- `handleIncomingStreamEvent(_:)` — Process SSE events including `.artifact` type
- `buildCardFromArtifact(type:content:actions:status:artifactId:)` — Converts artifact SSE data to `CanvasCardModel` via JSON round-trip decoding. When `artifactId` is provided (pre-generated by Firebase), it becomes the card's stable identity and is stored in `CardMeta` for artifact action routing. Supports: `session_plan`, `routine_summary`, `analysis_summary`, `visualization`.

**Artifact Flow:**
1. Agent tool returns `artifact_type` in response
2. `stream-agent-normalized.js` pre-generates a Firestore doc ID, includes it as `artifact_id` in the SSE `artifact` event, then persists to Firestore with the same ID
3. `handleIncomingStreamEvent()` receives `.artifact` case, extracts `artifact_id`
4. `buildCardFromArtifact()` converts to `CanvasCardModel` with artifact provenance in `CardMeta`
5. Card appended to `cards` array, rendered by existing card components
6. Action handlers in `CanvasScreen` route through `AgentsApi.artifactAction()` when `CardMeta.artifactId` is present

**Firestore Listeners:**
- Workspace events (for reload)
- Canvas events (telemetry)

## Cross-References

- Views: `Povver/Povver/Views/CanvasScreen.swift`, `UI/Canvas/`
- Services: `DirectStreamingService.swift`, `AgentsApi.swift`
- Card renderers: `UI/Canvas/Cards/SessionPlanCard.swift`, `RoutineSummaryCard.swift`, etc.
